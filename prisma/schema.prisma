generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  directUrl  = env("DIRECT_URL")
  extensions = [vector]
}

// NextAuth.js Models
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model User {
  id                  String         @id @default(cuid())
  clerkUserId         String?        @unique // Clerk user ID for new auth system
  name                String?
  email               String?        @unique
  emailVerified       DateTime?
  image               String?
  displayName         String?
  selectedIcon        String?
  avatarBackground    String?
  createdAt           DateTime       @default(now())
  updatedAt           DateTime       @updatedAt
  role                UserRole       @default(USER)
  lastSpoilerPrompt   DateTime?
  spoilerBlockDate    DateTime?
  spoilerBlockEnabled Boolean        @default(false)
  accounts            Account[]
  sessions            Session[]
  games               Game[]
  gameHistory         GameHistory[]
  userProgress        UserProgress[]
  disputes            AnswerDispute[] @relation("DisputeUser")
  resolvedDisputes    AnswerDispute[] @relation("DisputeAdmin")
  answerOverrides     AnswerOverride[]
}

model Question {
  id                String                         @id @default(uuid())
  question          String
  answer            String
  value             Int
  difficulty        Difficulty
  categoryId        String
  knowledgeCategory KnowledgeCategory
  airDate           DateTime?
  season            Int?
  episodeId         String?
  createdAt         DateTime                       @default(now())
  updatedAt         DateTime                       @updatedAt
  wasTripleStumper  Boolean                        @default(false)
  isDoubleJeopardy  Boolean                        @default(false) // @deprecated - use 'round' instead
  round             JeopardyRound                  @default(SINGLE)
  embedding         Unsupported("vector(1536)")?
  gameHistory       GameHistory[]
  games             GameQuestion[]
  category          Category                       @relation(fields: [categoryId], references: [id])
  userProgress      UserProgress[]
  tags              Tag[]                          @relation("QuestionTags")
  answerOverrides   AnswerOverride[]
  disputes          AnswerDispute[]

  @@index([categoryId])
  @@index([knowledgeCategory])
  @@index([airDate])
  @@index([round])
}

model Category {
  id                String                         @id @default(uuid())
  name              String                         @unique
  knowledgeCategory KnowledgeCategory?
  embedding         Unsupported("vector(1536)")?
  createdAt         DateTime                       @default(now())
  updatedAt         DateTime                       @updatedAt
  questions         Question[]
  userProgress      UserProgress[]

  @@index([knowledgeCategory])
}

model Tag {
  id        String     @id @default(uuid())
  name      String     @unique
  questions Question[] @relation("QuestionTags")
}

model KnowledgeCategoryEmbedding {
  id                String                       @id @default(uuid())
  knowledgeCategory KnowledgeCategory            @unique
  description       String
  embedding         Unsupported("vector(1536)")
  createdAt         DateTime                     @default(now())
  updatedAt         DateTime                     @updatedAt
}

model GameHistory {
  id         String   @id @default(uuid())
  userId     String
  questionId String
  correct    Boolean
  points     Int      @default(0)
  userAnswer String?  @db.Text // Optional: raw user answer for retroactive re-grading
  timestamp  DateTime @default(now())
  question   Question @relation(fields: [questionId], references: [id])
  user       User     @relation(fields: [userId], references: [id])
  
  @@index([userId, questionId])
}

model UserProgress {
  id         String   @id @default(uuid())
  userId     String
  categoryId String
  questionId String
  correct    Int      @default(0)
  total      Int      @default(0)
  points     Int      @default(0)
  category   Category @relation(fields: [categoryId], references: [id])
  question   Question @relation(fields: [questionId], references: [id])
  user       User     @relation(fields: [userId], references: [id])

  @@unique([userId, categoryId])
}

model Game {
  id                     String         @id @default(uuid())
  userId                 String
  useKnowledgeCategories Boolean        @default(false)
  score                  Int            @default(0)
  completed              Boolean        @default(false)
  createdAt              DateTime       @default(now())
  updatedAt              DateTime       @updatedAt
  
  // New fields for resumable games and multiplayer support
  seed                   String?        @unique // Short opaque identifier for sharing/recreating games
  config                 Json?          // Full game configuration (mode, categories, rounds, etc.)
  status                 GameStatus     @default(IN_PROGRESS)
  currentRound           JeopardyRound  @default(SINGLE)
  currentScore           Int            @default(0) // Tracks score during gameplay (separate from final score)
  visibility             GameVisibility @default(PRIVATE)
  
  // Multiplayer-ready fields (nullable for now)
  opponentUserId         String?        // For future 2-player games
  
  user                   User           @relation(fields: [userId], references: [id])
  questions              GameQuestion[]

  @@index([userId, status])
  @@index([seed])
}

model GameQuestion {
  id         String   @id @default(uuid())
  gameId     String
  questionId String
  answered   Boolean  @default(false)
  correct    Boolean?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  game       Game     @relation(fields: [gameId], references: [id])
  question   Question @relation(fields: [questionId], references: [id])

  @@unique([gameId, questionId])
}

enum Difficulty {
  EASY
  MEDIUM
  HARD
}

enum JeopardyRound {
  SINGLE
  DOUBLE
  FINAL
}

enum UserRole {
  USER
  ADMIN
}

enum KnowledgeCategory {
  GEOGRAPHY_AND_HISTORY
  ENTERTAINMENT
  ARTS_AND_LITERATURE
  SCIENCE_AND_NATURE
  SPORTS_AND_LEISURE
  GENERAL_KNOWLEDGE
}

enum GameStatus {
  IN_PROGRESS
  COMPLETED
  ABANDONED
}

enum GameVisibility {
  PRIVATE
  UNLISTED
  PUBLIC
}

enum DisputeStatus {
  PENDING
  APPROVED
  REJECTED
}

enum DisputeMode {
  GAME
  PRACTICE
}

enum OverrideSource {
  ADMIN
  DISPUTE
}

model AnswerOverride {
  id            String         @id @default(uuid())
  questionId   String
  text          String         @db.Text // Normalized acceptable answer string
  createdByUserId String
  source        OverrideSource
  notes         String?        @db.Text
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  question      Question       @relation(fields: [questionId], references: [id], onDelete: Cascade)
  createdBy     User           @relation(fields: [createdByUserId], references: [id])
  disputes      AnswerDispute[]

  @@unique([questionId, text])
  @@index([questionId])
  @@index([createdByUserId])
}

model AnswerDispute {
  id              String         @id @default(uuid())
  userId          String
  questionId      String
  gameId          String?        // Nullable for practice-only disputes
  mode            DisputeMode
  round           JeopardyRound
  userAnswer      String         @db.Text // Raw user answer string
  systemWasCorrect Boolean       // What the system judged
  status          DisputeStatus  @default(PENDING)
  adminId         String?        // Admin who resolved the dispute
  adminComment    String?        @db.Text
  overrideId      String?        // Link to AnswerOverride if approved
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  resolvedAt      DateTime?
  user            User           @relation("DisputeUser", fields: [userId], references: [id], onDelete: Cascade)
  admin           User?          @relation("DisputeAdmin", fields: [adminId], references: [id])
  question        Question       @relation(fields: [questionId], references: [id], onDelete: Cascade)
  override        AnswerOverride? @relation(fields: [overrideId], references: [id])

  @@index([userId])
  @@index([questionId])
  @@index([status])
  @@index([createdAt])
  @@index([userId, questionId, mode])
}
