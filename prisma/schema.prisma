generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  directUrl  = env("DIRECT_URL")
  extensions = [vector]
}

// NextAuth.js Models
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model User {
  id                  String         @id @default(cuid())
  clerkUserId         String?        @unique // Clerk user ID for new auth system
  name                String?
  email               String?        @unique
  emailVerified       DateTime?
  image               String?
  displayName         String?
  selectedIcon        String?
  avatarBackground    String?
  createdAt           DateTime       @default(now())
  updatedAt           DateTime       @updatedAt
  role                UserRole       @default(USER)
  lastSpoilerPrompt   DateTime?
  spoilerBlockDate    DateTime?
  spoilerBlockEnabled Boolean        @default(false)
  currentStreak       Int            @default(0)
  longestStreak       Int            @default(0)
  lastGameDate        DateTime?
  accounts            Account[]
  sessions            Session[]
  games               Game[]
  gameHistory         GameHistory[]
  userProgress        UserProgress[]
  disputes            AnswerDispute[] @relation("DisputeUser")
  resolvedDisputes    AnswerDispute[] @relation("DisputeAdmin")
  answerOverrides     AnswerOverride[]
  dailyChallenges     UserDailyChallenge[]
  achievements        UserAchievement[]
  claimedGuestSessions GuestSession[] @relation("ClaimedGuestSessions")
}

model Question {
  id                String                         @id @default(uuid())
  question          String
  answer            String
  value             Int
  difficulty        Difficulty
  categoryId        String
  knowledgeCategory KnowledgeCategory
  airDate           DateTime?
  season            Int?
  episodeId         String?
  createdAt         DateTime                       @default(now())
  updatedAt         DateTime                       @updatedAt
  wasTripleStumper  Boolean                        @default(false)
  isDoubleJeopardy  Boolean                        @default(false) // @deprecated - use 'round' instead
  round             JeopardyRound                  @default(SINGLE)
  embedding         Unsupported("vector(1536)")?
  gameHistory       GameHistory[]
  games             GameQuestion[]
  category          Category                       @relation(fields: [categoryId], references: [id])
  userProgress      UserProgress[]
  tags              Tag[]                          @relation("QuestionTags")
  answerOverrides   AnswerOverride[]
  disputes          AnswerDispute[]
  dailyChallenges   DailyChallenge[]
  guestGameQuestions GuestGameQuestion[]

  @@index([categoryId])
  @@index([knowledgeCategory])
  @@index([airDate])
  @@index([round])
  @@index([round, airDate]) // Composite index for daily challenge queries
}

model Category {
  id                String                         @id @default(uuid())
  name              String                         @unique
  knowledgeCategory KnowledgeCategory?
  embedding         Unsupported("vector(1536)")?
  createdAt         DateTime                       @default(now())
  updatedAt         DateTime                       @updatedAt
  questions         Question[]
  userProgress      UserProgress[]

  @@index([knowledgeCategory])
}

model Tag {
  id        String     @id @default(uuid())
  name      String     @unique
  questions Question[] @relation("QuestionTags")
}

model KnowledgeCategoryEmbedding {
  id                String                       @id @default(uuid())
  knowledgeCategory KnowledgeCategory            @unique
  description       String
  embedding         Unsupported("vector(1536)")
  createdAt         DateTime                     @default(now())
  updatedAt         DateTime                     @updatedAt
}

model GameHistory {
  id         String   @id @default(uuid())
  userId     String
  questionId String
  correct    Boolean
  points     Int      @default(0)
  userAnswer String?  @db.Text // Optional: raw user answer for retroactive re-grading
  timestamp  DateTime @default(now())
  question   Question @relation(fields: [questionId], references: [id])
  user       User     @relation(fields: [userId], references: [id])
  
  @@index([userId, questionId])
}

model UserProgress {
  id         String   @id @default(uuid())
  userId     String
  categoryId String
  questionId String
  correct    Int      @default(0)
  total      Int      @default(0)
  points     Int      @default(0)
  category   Category @relation(fields: [categoryId], references: [id])
  question   Question @relation(fields: [questionId], references: [id])
  user       User     @relation(fields: [userId], references: [id])

  @@unique([userId, categoryId])
}

model Game {
  id                     String         @id @default(uuid())
  userId                 String
  useKnowledgeCategories Boolean        @default(false)
  score                  Int            @default(0)
  completed              Boolean        @default(false)
  createdAt              DateTime       @default(now())
  updatedAt              DateTime       @updatedAt
  
  // New fields for resumable games and multiplayer support
  seed                   String?        @unique // Short opaque identifier for sharing/recreating games
  config                 Json?          // Full game configuration (mode, categories, rounds, etc.)
  status                 GameStatus     @default(IN_PROGRESS)
  currentRound           JeopardyRound  @default(SINGLE)
  currentScore           Int            @default(0) // Tracks score during gameplay (separate from final score)
  visibility             GameVisibility @default(PRIVATE)
  
  // Multiplayer-ready fields (nullable for now)
  opponentUserId         String?        // For future 2-player games
  
  user                   User           @relation(fields: [userId], references: [id])
  questions              GameQuestion[]

  @@index([userId, status])
  @@index([seed])
}

model GameQuestion {
  id         String   @id @default(uuid())
  gameId     String
  questionId String
  answered   Boolean  @default(false)
  correct    Boolean?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  game       Game     @relation(fields: [gameId], references: [id])
  question   Question @relation(fields: [questionId], references: [id])

  @@unique([gameId, questionId])
}

enum Difficulty {
  EASY
  MEDIUM
  HARD
}

enum JeopardyRound {
  SINGLE
  DOUBLE
  FINAL
}

enum UserRole {
  USER
  ADMIN
}

enum KnowledgeCategory {
  GEOGRAPHY_AND_HISTORY
  ENTERTAINMENT
  ARTS_AND_LITERATURE
  SCIENCE_AND_NATURE
  SPORTS_AND_LEISURE
  GENERAL_KNOWLEDGE
}

enum GameStatus {
  IN_PROGRESS
  COMPLETED
  ABANDONED
}

enum GameVisibility {
  PRIVATE
  UNLISTED
  PUBLIC
}

enum DisputeStatus {
  PENDING
  APPROVED
  REJECTED
}

enum DisputeMode {
  GAME
  PRACTICE
}

enum OverrideSource {
  ADMIN
  DISPUTE
}

enum GuestSessionType {
  RANDOM_QUESTION
  RANDOM_GAME
  DAILY_CHALLENGE
}

model AnswerOverride {
  id            String         @id @default(uuid())
  questionId   String
  text          String         @db.Text // Normalized acceptable answer string
  createdByUserId String
  source        OverrideSource
  notes         String?        @db.Text
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  question      Question       @relation(fields: [questionId], references: [id], onDelete: Cascade)
  createdBy     User           @relation(fields: [createdByUserId], references: [id])
  disputes      AnswerDispute[]

  @@unique([questionId, text])
  @@index([questionId])
  @@index([createdByUserId])
}

model AnswerDispute {
  id              String         @id @default(uuid())
  userId          String
  questionId      String
  gameId          String?        // Nullable for practice-only disputes
  mode            DisputeMode
  round           JeopardyRound
  userAnswer      String         @db.Text // Raw user answer string
  systemWasCorrect Boolean       // What the system judged
  status          DisputeStatus  @default(PENDING)
  adminId         String?        // Admin who resolved the dispute
  adminComment    String?        @db.Text
  overrideId      String?        // Link to AnswerOverride if approved
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  resolvedAt      DateTime?
  user            User           @relation("DisputeUser", fields: [userId], references: [id], onDelete: Cascade)
  admin           User?          @relation("DisputeAdmin", fields: [adminId], references: [id])
  question        Question       @relation(fields: [questionId], references: [id], onDelete: Cascade)
  override        AnswerOverride? @relation(fields: [overrideId], references: [id])

  @@index([userId])
  @@index([questionId])
  @@index([status])
  @@index([createdAt])
  @@index([userId, questionId, mode])
}

model DailyChallenge {
  id        String   @id @default(uuid())
  date      DateTime @unique @db.Date
  questionId String  @unique // Ensure each question can only be used once as a daily challenge
  airDate   DateTime?
  episodeGameId String? // Track which game/episode was used (from J-Archive)
  createdAt DateTime @default(now())
  question  Question @relation(fields: [questionId], references: [id])
  completions UserDailyChallenge[]

  @@index([date])
  @@index([questionId])
  @@index([airDate])
  @@index([episodeGameId])
}

model UserDailyChallenge {
  id          String   @id @default(uuid())
  userId      String
  challengeId String
  correct     Boolean
  completedAt DateTime @default(now())
  user        User     @relation(fields: [userId], references: [id])
  challenge   DailyChallenge @relation(fields: [challengeId], references: [id])
  
  @@unique([userId, challengeId])
  @@index([challengeId, correct])
}

model Achievement {
  id          String   @id @default(uuid())
  code        String   @unique
  name        String
  description String
  icon        String?
  userAchievements UserAchievement[]

  @@index([code])
}

model UserAchievement {
  id            String   @id @default(uuid())
  userId        String
  achievementId String
  unlockedAt    DateTime @default(now())
  user          User     @relation(fields: [userId], references: [id])
  achievement   Achievement @relation(fields: [achievementId], references: [id])
  
  @@unique([userId, achievementId])
  @@index([userId])
  @@index([achievementId])
}

model GuestSession {
  id              String           @id @default(uuid())
  type            GuestSessionType
  data            Json?            // Flexible storage for session-specific data
  createdAt       DateTime         @default(now())
  expiresAt       DateTime         // When the session expires and can no longer be claimed
  claimedAt       DateTime?
  claimedByUserId String?
  claimedBy       User?            @relation("ClaimedGuestSessions", fields: [claimedByUserId], references: [id])
  guestGame       GuestGame?
  
  @@index([expiresAt])
  @@index([claimedByUserId])
  @@index([type, expiresAt])
}

model GuestGame {
  id              String           @id @default(uuid())
  guestSessionId String           @unique
  seed            String?          @unique
  config          Json?            // Game configuration (mode, rounds, etc.)
  status          GameStatus       @default(IN_PROGRESS)
  currentRound    JeopardyRound    @default(SINGLE)
  currentScore    Int              @default(0)
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  guestSession    GuestSession     @relation(fields: [guestSessionId], references: [id], onDelete: Cascade)
  questions       GuestGameQuestion[]
  
  @@index([guestSessionId])
}

model GuestGameQuestion {
  id         String   @id @default(uuid())
  guestGameId String
  questionId String
  answered   Boolean  @default(false)
  correct    Boolean?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  guestGame  GuestGame @relation(fields: [guestGameId], references: [id], onDelete: Cascade)
  question   Question @relation(fields: [questionId], references: [id])
  
  @@unique([guestGameId, questionId])
}

model GuestConfig {
  id                              String  @id @default(uuid())
  // Random game limits
  randomGameMaxQuestionsBeforeAuth Int     @default(1)
  randomGameMaxCategoriesBeforeAuth Int?   // Null means not enforced
  randomGameMaxRoundsBeforeAuth    Int?    // Null means not enforced
  randomGameMaxGamesBeforeAuth     Int     @default(0) // 0 means not enforced
  // Random question limits
  randomQuestionMaxQuestionsBeforeAuth Int @default(1)
  randomQuestionMaxCategoriesBeforeAuth Int? // Null means not enforced
  // Daily challenge settings
  dailyChallengeGuestEnabled      Boolean @default(false) // Default: auth required
  dailyChallengeGuestAppearsOnLeaderboard Boolean @default(false)
  dailyChallengeMinLookbackDays   Int     @default(365) // Minimum days to look back (default 1 year)
  dailyChallengeSeasons          Json?   // Array of season numbers to choose episodes from (e.g., [38, 39, 40])
  // Global TTL
  timeToAuthenticateMinutes       Int     @default(1440) // Default 24 hours
  createdAt                       DateTime @default(now())
  updatedAt                       DateTime @updatedAt
  
  @@unique([id]) // Single row configuration
}

model CronJobExecution {
  id            String   @id @default(uuid())
  jobName       String   // e.g., 'daily-challenge', 'fetch-questions'
  status        CronJobStatus
  startedAt     DateTime @default(now())
  completedAt   DateTime?
  durationMs    Int?     // Duration in milliseconds
  result        Json?    // Store job result/output
  error         String?  @db.Text // Error message if failed
  triggeredBy   String?  // 'scheduled' or 'manual' or user ID if manually triggered
  createdAt     DateTime @default(now())
  
  @@index([jobName, startedAt])
  @@index([status])
  @@index([startedAt])
}

enum CronJobStatus {
  RUNNING
  SUCCESS
  FAILED
}
